# Inheritance - Interview Preparation

## üîó Quick Links
- [How to Identify When to Use Inheritance](#how-to-identify-when-to-use-inheritance) - IS-A test and decision tree
- [Understanding Object Creation in Inheritance](#understanding-object-creation-in-inheritance) - Memory layout explained
- [Constructor/Destructor Order in Inheritance](#constructor-destructor-order) - From constructors-destructors topic
- [Types of Inheritance](#types-of-inheritance) - Single, Multiple, Multilevel, Hierarchical, Hybrid

## üìö Topics Covered

### Part 1: Inheritance Basics ‚úÖ
- What is Inheritance?
- Why use Inheritance? (Code reuse, IS-A relationship)
- Base class and Derived class
- Access specifiers in inheritance (public, protected, private)
- File: [`01_inheritance_basics.cpp`](./01_inheritance_basics.cpp)

### Part 2: Types of Inheritance ‚úÖ
- Single Inheritance
- Multiple Inheritance
- Multilevel Inheritance
- Hierarchical Inheritance
- Hybrid Inheritance
- Diamond Problem
- Virtual Inheritance (Solution)
- File: [`02_types_of_inheritance.cpp`](./02_types_of_inheritance.cpp)

### Part 3: Access Control in Inheritance ‚úÖ
- Public inheritance (IS-A relationship)
- Protected inheritance
- Private inheritance (HAS-A implementation)
- Access specifier transformation rules
- File: [`03_access_control.cpp`](./03_access_control.cpp)

### Part 4: Constructor & Destructor in Inheritance ‚úÖ
- Order of constructor calls (Base ‚Üí Derived)
- Order of destructor calls (Derived ‚Üí Base)
- Calling base class constructors
- Virtual destructors (IMPORTANT!)
- File: [`04_constructor_destructor_order.cpp`](./04_constructor_destructor_order.cpp)

### Part 5: Function Overriding ‚úÖ
- What is function overriding?
- Overriding vs Overloading
- Virtual functions
- Runtime polymorphism
- File: [`05_function_overriding.cpp`](./05_function_overriding.cpp)

### Part 6: Virtual Functions & Polymorphism ‚úÖ
- Virtual functions
- Pure virtual functions (Abstract classes)
- Virtual table (vtable)
- Runtime polymorphism
- File: [`06_virtual_functions.cpp`](./06_virtual_functions.cpp)

### Part 7: Abstract Classes & Interfaces
- Pure virtual functions
- Abstract classes (cannot instantiate)
- Interfaces in C++
- Real-world examples
- File: [`07_abstract_classes.cpp`](./07_abstract_classes.cpp)

### Part 8: Multiple Inheritance & Diamond Problem
- Multiple inheritance challenges
- Diamond problem
- Virtual inheritance (solution)
- Real-world use cases
- File: [`08_multiple_inheritance.cpp`](./08_multiple_inheritance.cpp)

### Part 9: Real-World Examples
- Employee hierarchy
- Shape hierarchy
- File system hierarchy
- Animal classification
- File: [`09_realworld_examples.cpp`](./09_realworld_examples.cpp)

### Part 10: Interview Questions
- Common inheritance questions
- Tricky scenarios
- Best practices
- File: [`10_interview_questions.cpp`](./10_interview_questions.cpp)

---

## üí° Extra Knowledge - Common Confusions

### Private Inheritance vs Final Keyword

**‚ö†Ô∏è IMPORTANT: These are DIFFERENT concepts!**

#### 1. Private Inheritance (Hiding Base Interface)
```cpp
class GPS {
public:
    void showLocation() { }
};

class SmartPhone : private GPS {  // Private inheritance
    // GPS interface hidden from outside
};

class AdvancedPhone : public SmartPhone {
    // ‚úÖ ALLOWED! Can still inherit from SmartPhone
    // ‚ùå But can't access GPS members
};
```

**Purpose:**
- Hides base class interface from outside world
- Implementation detail (HAS-A relationship)
- **Does NOT prevent further inheritance**
- Further classes can inherit, but can't access private base

#### 2. Final Keyword (Preventing Inheritance)
```cpp
class Base {
public:
    void baseMethod() { }
};

class Derived final : public Base {  // ‚Üê final keyword
    // This is the LAST class in hierarchy
};

class FurtherDerived : public Derived {
    // ‚ùå ERROR! Cannot inherit from final class
    // Compilation error!
};
```

**Purpose:**
- **Completely prevents ANY inheritance**
- No class can derive from a final class
- Used for: Security, performance optimization, design enforcement

#### When to Use Each?

| Scenario | Use |
|----------|-----|
| Hide implementation details (HAS-A) | Private Inheritance |
| Prefer composition over private inheritance | ‚úÖ Composition (better!) |
| Stop ALL inheritance completely | `final` keyword |
| Allow inheritance but hide base members | Private Inheritance |
| Performance critical class (no vtable) | `final` keyword |

**Real-World Examples:**
```cpp
// Private Inheritance (rare, prefer composition)
class Stack : private std::vector<int> {
    // vector is implementation detail
    // But other classes can inherit from Stack
};

// Final keyword (prevent inheritance)
class String final {
    // No one should inherit from String
    // It's a complete, sealed class
};

// Java example: public final class String
// C# example: public sealed class String
```

**Interview Tip:** If asked "How to prevent inheritance?" ‚Üí Answer: `final` keyword (C++11)  
If asked "What does private inheritance do?" ‚Üí Answer: Hides base interface, but doesn't prevent inheritance

---

## üéØ Interview Key Points to Remember

### Inheritance:
- [ ] **IS-A relationship** - Derived class "is a type of" Base class
- [ ] **Code reuse** - Inherit common functionality
- [ ] **Extensibility** - Add new features without modifying base
- [ ] **Polymorphism** - Base class pointer ‚Üí Derived class object
- [ ] **Access specifiers** - public, protected, private inheritance

### Constructor/Destructor Order:
- [ ] **Construction:** Base ‚Üí Derived (top-down)
- [ ] **Destruction:** Derived ‚Üí Base (bottom-up, reverse)
- [ ] **Virtual destructor** - MUST have in base class if using inheritance
- [ ] **Base constructor call** - Use initialization list in derived class

### Types of Inheritance:
- [ ] **Single** - One base, one derived
- [ ] **Multiple** - Multiple bases, one derived (Diamond problem!)
- [ ] **Multilevel** - Chain: A ‚Üí B ‚Üí C
- [ ] **Hierarchical** - One base, multiple derived
- [ ] **Hybrid** - Combination of above

### Virtual Functions:
- [ ] **Runtime polymorphism** - Function call resolved at runtime
- [ ] **Virtual keyword** - Makes function overridable
- [ ] **Pure virtual** - `virtual void func() = 0;` (abstract)
- [ ] **vtable** - Virtual function table (how it works internally)
- [ ] **Override keyword** - C++11, explicit override (recommended)

---

## üöÄ Progress Tracker
- [x] Part 1: Inheritance Basics ‚úÖ
- [x] Part 2: Types of Inheritance ‚úÖ
- [ ] Part 3: Access Control
- [ ] Part 4: Constructor/Destructor Order
- [ ] Part 5: Function Overriding
- [ ] Part 6: Virtual Functions
- [ ] Part 7: Abstract Classes
- [ ] Part 8: Multiple Inheritance
- [ ] Part 9: Real-World Examples
- [ ] Part 10: Interview Questions

---

## üìñ Core Concepts

### What is Inheritance?

**Definition:** Inheritance is a mechanism where a new class (derived/child) acquires properties and behaviors of an existing class (base/parent).

```cpp
class Animal {          // Base class
    void eat() { }
};

class Dog : public Animal {  // Derived class
    void bark() { }
};

// Dog inherits eat() from Animal
// Dog IS-A Animal
```

### Why Use Inheritance?

1. **Code Reuse** - Don't repeat common code
2. **Logical Hierarchy** - Model real-world relationships
3. **Extensibility** - Add features without changing base
4. **Polymorphism** - Treat derived objects as base objects

### IS-A vs HAS-A Relationship

```cpp
// IS-A relationship (Inheritance)
class Car : public Vehicle { };  // Car IS-A Vehicle

// HAS-A relationship (Composition)
class Car {
    Engine engine;  // Car HAS-A Engine
};
```

**Rule of thumb:** Use inheritance for IS-A, composition for HAS-A

---

## üîç How to Identify When to Use Inheritance

### The IS-A Test (Primary Indicator)

**Question to ask:** "Is X a type of Y?"

```
‚úÖ YES ‚Üí Use Inheritance
- Dog IS-A Animal ‚úì
- Coffee IS-A Drink ‚úì
- Manager IS-A Employee ‚úì
- SavingsAccount IS-A BankAccount ‚úì

‚ùå NO ‚Üí Use Composition (or no relationship)
- Car IS-A Engine? ‚úó (Car HAS-A Engine)
- House IS-A Door? ‚úó (House HAS-A Door)
- Student IS-A Book? ‚úó (Student HAS-A Book)
```

### How to Identify Base Class

#### Step 1: Find Common Characteristics

```
Example: Analyzing Coffee Shop Drinks

Entities: Coffee, Tea, Juice, Smoothie

Common properties:
- All have a name
- All have a price
- All have a temperature
- All can be served

Common concept: DRINK

Decision: Create "Drink" as base class ‚úì
```

#### Step 2: Apply IS-A Test

```
Coffee IS-A Drink? ‚úì
Tea IS-A Drink? ‚úì
Juice IS-A Drink? ‚úì
Smoothie IS-A Drink? ‚úì

Conclusion: "Drink" should be base class
```

#### Step 3: Design Hierarchy

```cpp
class Drink {  // Base class - common behavior
protected:
    string name;
    double price;
    int temperature;
};

class Coffee : public Drink { };  // Specific type
class Tea : public Drink { };
class Juice : public Drink { };
```

### Decision Tree

```
Start: Multiple similar entities exist
          ‚Üì
Question: Do they share characteristics?
          ‚Üì
        YES
          ‚Üì
Question: "X IS-A Y" - Natural statement?
          ‚Üì
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   YES         NO
    ‚Üì           ‚Üì
Create      Use Composition
Base Class  or Functions
    ‚Üì
Extract      Design hierarchy:
common       Base (general)
features        ‚Üì
into base    Derived (specific)
```

### Real-World Examples

#### Example 1: Vehicle System

```
Observation: Car, Bike, Truck exist

Step 1: Find commonality
- All have brand, year
- All can start(), stop()
- All move on roads

Step 2: IS-A test
- Car IS-A Vehicle? ‚úì
- Bike IS-A Vehicle? ‚úì
- Truck IS-A Vehicle? ‚úì

Step 3: Identify base
Base class: Vehicle (common concept)

Result:
class Vehicle { };      // Base
class Car : public Vehicle { };
class Bike : public Vehicle { };
```

#### Example 2: Employee Hierarchy

```
Observation: Manager, Developer, Intern exist

Step 1: Find commonality
- All have name, ID, salary
- All work for company
- All have common HR processes

Step 2: IS-A test
- Manager IS-A Employee? ‚úì
- Developer IS-A Employee? ‚úì
- Intern IS-A Employee? ‚úì

Step 3: Identify base
Base class: Employee

Result:
class Employee { };     // Base
class Manager : public Employee { };
class Developer : public Employee { };
```

#### Example 3: Counter-Example (NO Inheritance)

```
Observation: Car and Engine exist

Step 1: Relationship?
- Car uses Engine
- Car contains Engine

Step 2: IS-A test
- Car IS-A Engine? ‚úó (Makes no sense!)

Step 3: Alternative
Use composition (HAS-A):

class Car {
    Engine engine;  // Car HAS-A Engine
};
```

### When NOT to Use Inheritance

‚ùå **Don't use inheritance if:**

1. **No IS-A relationship**
   ```cpp
   // ‚ùå WRONG
   class Car : public Engine { };  // Car IS-A Engine? No!
   ```

2. **Just for code reuse**
   ```cpp
   // ‚ùå WRONG - Using inheritance just to reuse utility methods
   class MyClass : public UtilityFunctions { };
   
   // ‚úì CORRECT - Use composition or helper functions
   class MyClass {
       UtilityFunctions utils;  // Has utility
   };
   ```

3. **Violates Liskov Substitution Principle**
   ```cpp
   // ‚ùå WRONG - Square is NOT a proper Rectangle subtype
   class Square : public Rectangle { };
   // Problem: Setting width/height independently breaks for Square
   ```

4. **Creates tight coupling**
   ```cpp
   // ‚ùå WRONG - Implementation inheritance for convenience
   class ArrayList : public Vector { };  // Too tightly coupled
   ```

### Checklist: Should I Use Inheritance?

```
‚òë Does "X IS-A Y" make logical sense?
‚òë Are there shared properties/behaviors?
‚òë Do I need polymorphism (treat X as Y)?
‚òë Is there a natural hierarchy?
‚òë Can derived class be substituted for base class?

If 3+ checks pass ‚Üí Use Inheritance ‚úì
If less than 3 ‚Üí Consider Composition or other design
```

### Protected vs Private in Base Class

**When designing base class:**

```cpp
class Base {
private:
    int internalDetail;  // Implementation detail, hide from everyone
    
protected:
    int sharedData;      // Derived classes need access
    
    void helperMethod() {  // Derived classes can use
        // ...
    }
    
public:
    void publicInterface() {  // Everyone can use
        // ...
    }
};
```

**Guidelines:**
- **private:** Internal implementation, derived classes don't need
- **protected:** Data/methods that derived classes need to access or override
- **public:** Interface for all users (including derived classes)

**Common pattern:**
```cpp
class BankAccount {
private:
    double balance;  // Keep private (sensitive)
    
protected:
    // Provide controlled access for derived classes
    double getBalance() const { return balance; }
    void setBalance(double b) { balance = b; }
    
public:
    void deposit(double amount);  // Public interface
};
```

---

## üß† Understanding Object Creation in Inheritance

### The Key Question: What Happens in Memory?

**Common Misconception:** "When derived object is created, does it reference a separate base object?"

**Reality:** There is **ONE single object** containing both base and derived parts!

### Memory Layout

```cpp
class Base {
    int baseVar;
};

class Derived : public Base {
    int derivedVar;
};

Derived d;  // What's in memory?
```

**Visual Representation:**

```
‚ùå WRONG: Two separate objects
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Base object ‚îÇ ‚Üê baseVar
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚Üë reference?
       ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Derived obj ‚îÇ ‚Üê derivedVar
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


‚úÖ CORRECT: One object with two parts
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Derived Object 'd' ‚îÇ  ‚Üê ONE object in memory
‚îÇ                     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ Base Part     ‚îÇ  ‚îÇ ‚Üê baseVar (constructed first)
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ Derived Part  ‚îÇ  ‚îÇ ‚Üê derivedVar (constructed second)
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Creation Process

```
Step 1: Memory Allocation
  - Allocate space for ENTIRE object
  - Size = sizeof(Base) + sizeof(Derived's own data)

Step 2: Base Constructor Runs
  - Initialize base class members
  - Base part is NOW ready

Step 3: Derived Constructor Runs
  - Initialize derived class members
  - Derived part is NOW ready

Result: ONE complete object with both parts
```

### Code Demonstration

```cpp
class Animal {
protected:
    string name;
public:
    Animal(string n) : name(n) {
        cout << "Animal constructor: " << this << endl;
    }
};

class Dog : public Animal {
private:
    string breed;
public:
    Dog(string n, string b) : Animal(n), breed(b) {
        cout << "Dog constructor: " << this << endl;
        // Notice: SAME memory address!
    }
};

Dog d("Buddy", "Golden");
// Output shows SAME address for both constructors
// Proof: It's ONE object!
```

### Key Points

1. ‚úÖ **Single Object:** Only ONE object exists in memory
2. ‚úÖ **Embedded Parts:** Base part is embedded INSIDE derived object
3. ‚úÖ **Contiguous Memory:** All parts are in sequential memory locations
4. ‚úÖ **Construction Order:** Base first, then derived (within same object)
5. ‚úÖ **No References:** No pointers/references between base and derived parts
6. ‚úÖ **Size:** `sizeof(Derived) >= sizeof(Base) + sizeof(Derived data)`

### Analogy: House with Floors

```
Think of derived object as a house with multiple floors:

House (Derived Object)
‚îú‚îÄ‚îÄ Ground Floor (Base part)   ‚Üê Built first
‚îÇ   ‚îî‚îÄ‚îÄ Foundation, structure
‚îî‚îÄ‚îÄ Upper Floor (Derived part) ‚Üê Built on top
    ‚îî‚îÄ‚îÄ Additional rooms

‚ùå NOT two separate buildings!
‚úÖ ONE building with two floors!
```

### Multiple Inheritance Case

```cpp
class A { int a; };
class B { int b; };
class C : public A, public B { int c; };

C obj;  // Memory layout:
```

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Object 'obj' (type C)     ‚îÇ  ‚Üê Still ONE object!
‚îÇ                             ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ   ‚îÇ A Part              ‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ   ‚îÇ B Part              ‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ   ‚îÇ C Part              ‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Interview Answer

**Q: When a derived class object is created, is there a separate base class object?**

**A:** No. When a derived object is created:
- Only **ONE object** exists in memory
- It contains the **base class part embedded** within it
- The base constructor runs **first** to initialize the base part
- Then the derived constructor runs to initialize the derived part
- All parts are in **contiguous memory** (not separate objects)
- There are **no references or pointers** between parts - they're physically part of the same object

Think of it as a single object with **layers**, not separate connected objects.

---

## üéì Interview Q&A

**Q1: What is inheritance?**
> Inheritance is an OOP mechanism where a derived class acquires properties and methods from a base class, enabling code reuse and establishing IS-A relationships.

**Q2: What are the types of inheritance in C++?**
> Single, Multiple, Multilevel, Hierarchical, and Hybrid inheritance. C++ supports all types, including multiple inheritance (unlike Java).

**Q3: What is the difference between public, protected, and private inheritance?**
> - **Public:** Base public members remain public in derived (IS-A relationship)
> - **Protected:** Base public members become protected in derived
> - **Private:** Base public/protected members become private in derived (HAS-A implementation)

**Q4: Why should base class destructor be virtual?**
> When deleting a derived object through a base pointer, without virtual destructor, only the base destructor is called ‚Üí memory leak. Virtual destructor ensures proper cleanup of derived class resources.

**Q5: What is the diamond problem?**
> In multiple inheritance, if two base classes inherit from a common grandparent, the derived class has two copies of grandparent members. Solution: Virtual inheritance.

**Q6: What is function overriding?**
> When a derived class provides a specific implementation of a function already defined in the base class. Requires same function signature. Use `virtual` for runtime polymorphism.

**Q7: What's the difference between overloading and overriding?**
> - **Overloading:** Same function name, different parameters, compile-time (same class)
> - **Overriding:** Same function signature, different implementation, runtime (inheritance)

**Q8: What is a pure virtual function?**
> A virtual function with `= 0` that has no implementation in base class. Makes the class abstract (cannot be instantiated). Derived classes must override it.

**Q9: When to use inheritance vs composition?**
> Use inheritance for IS-A relationships (natural hierarchy). Use composition for HAS-A relationships (building complex objects from simpler ones). Prefer composition over inheritance when in doubt.

**Q10: What is virtual inheritance?**
> A technique to solve the diamond problem in multiple inheritance. Uses `virtual` keyword in inheritance declaration to ensure only one copy of common base class.

---

## üìå Best Practices

1. ‚úÖ **Use public inheritance for IS-A relationships**
2. ‚úÖ **Make base class destructor virtual** (if using polymorphism)
3. ‚úÖ **Prefer composition over inheritance** (when relationship isn't clear)
4. ‚úÖ **Use `override` keyword** (C++11) for clarity
5. ‚úÖ **Keep inheritance hierarchies shallow** (avoid deep nesting)
6. ‚úÖ **Use abstract classes for interfaces** (pure virtual functions)
7. ‚úÖ **Avoid multiple inheritance** (unless necessary)
8. ‚úÖ **Call base constructor explicitly** (in derived class initialization list)

---

## üîç Coming Up

We'll explore:
- How inheritance enables polymorphism
- Virtual function tables (vtable)
- Abstract classes and interfaces
- Real-world design patterns using inheritance
- Common pitfalls and how to avoid them

Ready to dive in? Let's start with **Part 1: Inheritance Basics**! üöÄ
